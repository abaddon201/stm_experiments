/*
 * fonts.c
 *
 *  Created on: 2 сент. 2020 г.
 *      Author: user
 */

#include <stdint.h>
#include "stm32f4xx_hal.h"
#include "ff.h"

typedef struct _tFont {
    uint16_t Width;
    uint16_t Height;
    uint16_t bytesWidth;
    uint16_t *data;
} sFONT;

sFONT Font24;
sFONT Font20;
sFONT Font16;
sFONT Font12;
sFONT Font8;

void LoadFont(sFont *font, uint16_t w, uint16_t h, const char *fname) {
    FRESULT res; /* FatFs function common result code */
    if (f_open(&MyFile, fname, FA_READ) != FR_OK) {
        Error_Handler();
        return;
    }
    font->Width = w;
    font->Height = h;

    uint16_t symbolSize = h * (w + 7) / 8;
    font->data = malloc(95 * symbolSize);
    uint32_t bytesread;
    res = f_read(&MyFile, font->data, 8, &bytesRead);
    if ((bytesread == 0) || (res != FR_OK)) {
        free(font->data);
        font->data = 0;
        font->Width = 0;
        font->Height = 0;
        Error_Handler();
    }
}

void TFT9341_FontsIni(void) {
    Font8.Height = 8;
    Font8.Width = 5;
    Font12.Height = 12;
    Font12.Width = 7;
    Font16.Height = 16;
    Font16.Width = 11;
    Font20.Height = 20;
    Font20.Width = 14;
    Font24.Height = 24;
    Font24.Width = 17;
    lcdprop.BackColor = BLACK;
    lcdprop.TextColor = GREEN;
    lcdprop.pFont = &Font16;
}

void TFT9341_DrawChar(uint16_t x, uint16_t y, uint8_t s) {
    uint32_t bytesread;
    uint8_t charbuf[100];
    uint32_t i = 0, j = 0;
    uint16_t height, width;
    width = lcdprop.pFont->Width;
    height = lcdprop.pFont->Height;
    uint16_t fontsize = 0; //размер символа в байтах в таблице
    uint32_t line = 0; //горизонтальная линия пикселей шрифта
    uint8_t offset1; //разница между реальной шириной и шириной в байтах
    uint16_t offsetfile = 0; //Смещение символа в файле шрифта

    if ((x + lcdprop.pFont->Width) >= X_SIZE)
        return;

    switch (lcdprop.pFont->Height) {
    case 8:
        offset1 = 3;
        fontsize = 8; //размер символа в байтах
        HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET);
        offsetfile = (s - ' ') * fontsize;
        f_lseek(&MyFile, offsetfile);
        res = f_read(&MyFile, charbuf, 8, (void*) &bytesread);
        if ((bytesread == 0) || (res != FR_OK)) {
            Error_Handler();
        }
        break;
    case 12:
        offset1 = 1;
        fontsize = 12; //размер символа в байтах
        HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET);
        offsetfile = (s - ' ') * fontsize;
        f_lseek(&MyFile, offsetfile);
        res = f_read(&MyFile, charbuf, 12, (void*) &bytesread);
        if ((bytesread == 0) || (res != FR_OK)) {
            Error_Handler();
        }
        break;
    case 16:
        offset1 = 5;
        fontsize = 32; //размер символа в байтах
        HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET);
        offsetfile = (s - ' ') * fontsize;
        f_lseek(&MyFile, offsetfile);
        res = f_read(&MyFile, charbuf, 32, (void*) &bytesread);
        if ((bytesread == 0) || (res != FR_OK)) {
            Error_Handler();
        }
        break;
    case 20:
        offset1 = 2;
        fontsize = 40; //размер символа в байтах
        HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET);
        offsetfile = (s - ' ') * fontsize;
        f_lseek(&MyFile, offsetfile);
        res = f_read(&MyFile, charbuf, 40, (void*) &bytesread);
        if ((bytesread == 0) || (res != FR_OK)) {
            Error_Handler();
        }
        break;
    case 24:
        offset1 = 7;
        fontsize = 72; //размер символа в байтах
        HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET);
        offsetfile = (s - ' ') * fontsize;
        f_lseek(&MyFile, offsetfile);
        res = f_read(&MyFile, charbuf, 72, (void*) &bytesread);
        if ((bytesread == 0) || (res != FR_OK)) {
            Error_Handler();
        }
        break;
    }

    for (i = 0; i < height; i++) {
        if ((height == 8) || (height == 12)) {
            line = charbuf[i];
        } else if ((height == 16) || (height == 20)) {
            line = (charbuf[i * 2] << 8) | (charbuf[i * 2 + 1]);
        } else {
            line = (charbuf[i * 3] << 16) | (charbuf[i * 3 + 1] << 8) | (charbuf[i * 3 + 2]);
        }
//                line=0xFFFF;

        for (j = 0; j < width; j++) {
            if (line & (1 << (width - j + offset1 - 1))) {
                TFT9341_DrawPixel(x + j, y, lcdprop.TextColor);
            } else {
                TFT9341_DrawPixel(x + j, y, lcdprop.BackColor);
            }
        }
        y++;
    }
}

void TFT9341_SetFont(uint8_t f) {
    switch (f) {
    case 8:
        f_close(&MyFile);
        if (f_open(&MyFile, "font8.bin", FA_READ) != FR_OK) {
            Error_Handler();
        } else {
            lcdprop.pFont = &Font8;
        }
        break;
    case 12:
        f_close(&MyFile);
        if (f_open(&MyFile, "font12.bin", FA_READ) != FR_OK) {
            Error_Handler();
        } else {
            lcdprop.pFont = &Font12;
        }
        break;
    case 16:
        f_close(&MyFile);
        if (f_open(&MyFile, "font16.bin", FA_READ) != FR_OK) {
            Error_Handler();
        } else {
            lcdprop.pFont = &Font16;
        }
        break;
    case 20:
        f_close(&MyFile);
        if (f_open(&MyFile, "font20.bin", FA_READ) != FR_OK) {
            Error_Handler();
        } else {
            lcdprop.pFont = &Font20;
        }
        break;
    case 24:
        f_close(&MyFile);
        if (f_open(&MyFile, "font24.bin", FA_READ) != FR_OK) {
            Error_Handler();
        } else {
            lcdprop.pFont = &Font24;
        }
        break;
    }
}

void TFT9341_SetTextColor(uint16_t color) {
    lcdprop.TextColor = color;
}

//————————————————————–

void TFT9341_SetBackColor(uint16_t color) {
    lcdprop.BackColor = color;
}

void TFT9341_String(uint16_t x, uint16_t y, char *str) {
    while (*str) {
        TFT9341_DrawChar(x, y, str[0]);
        x += lcdprop.pFont->Width;
        (void) *str++;
    }
}
